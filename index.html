<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David Bindel">

<title>Simple 1D FEM in Julia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#shape-functions" id="toc-shape-functions" class="nav-link" data-scroll-target="#shape-functions">Shape functions</a>
  <ul class="collapse">
  <li><a href="#d-building-blocks" id="toc-d-building-blocks" class="nav-link" data-scroll-target="#d-building-blocks">1D building blocks</a></li>
  <li><a href="#shape-class-macro" id="toc-shape-class-macro" class="nav-link" data-scroll-target="#shape-class-macro">Shape class macro</a></li>
  <li><a href="#d-shape-functions" id="toc-d-shape-functions" class="nav-link" data-scroll-target="#d-shape-functions">1D shape functions</a></li>
  <li><a href="#d-shape-functions-1" id="toc-d-shape-functions-1" class="nav-link" data-scroll-target="#d-shape-functions-1">2D shape functions</a></li>
  <li><a href="#triangle-shapes" id="toc-triangle-shapes" class="nav-link" data-scroll-target="#triangle-shapes">Triangle shapes</a></li>
  </ul></li>
  <li><a href="#quadrature-rules" id="toc-quadrature-rules" class="nav-link" data-scroll-target="#quadrature-rules">Quadrature rules</a>
  <ul class="collapse">
  <li><a href="#gaussian-legendre-quadrature-rules" id="toc-gaussian-legendre-quadrature-rules" class="nav-link" data-scroll-target="#gaussian-legendre-quadrature-rules">Gaussian-Legendre quadrature rules</a></li>
  <li><a href="#quadrature-iterator-interface" id="toc-quadrature-iterator-interface" class="nav-link" data-scroll-target="#quadrature-iterator-interface">Quadrature iterator interface</a></li>
  <li><a href="#d-gauss-quadrature-interfaces" id="toc-d-gauss-quadrature-interfaces" class="nav-link" data-scroll-target="#d-gauss-quadrature-interfaces">1D Gauss quadrature interfaces</a></li>
  <li><a href="#product-gauss-rules" id="toc-product-gauss-rules" class="nav-link" data-scroll-target="#product-gauss-rules">Product Gauss rules</a></li>
  <li><a href="#triangle-mid-side-rule" id="toc-triangle-mid-side-rule" class="nav-link" data-scroll-target="#triangle-mid-side-rule">Triangle mid-side rule</a></li>
  </ul></li>
  <li><a href="#mapped-subdomains" id="toc-mapped-subdomains" class="nav-link" data-scroll-target="#mapped-subdomains">Mapped subdomains</a>
  <ul class="collapse">
  <li><a href="#mapping-functions-and-derivatives" id="toc-mapping-functions-and-derivatives" class="nav-link" data-scroll-target="#mapping-functions-and-derivatives">Mapping functions and derivatives</a></li>
  <li><a href="#mapped-quadrature" id="toc-mapped-quadrature" class="nav-link" data-scroll-target="#mapped-quadrature">Mapped quadrature</a></li>
  <li><a href="#iso-parametric-mapping" id="toc-iso-parametric-mapping" class="nav-link" data-scroll-target="#iso-parametric-mapping">Iso-parametric mapping</a></li>
  </ul></li>
  <li><a href="#mesh-geometry" id="toc-mesh-geometry" class="nav-link" data-scroll-target="#mesh-geometry">Mesh geometry</a>
  <ul class="collapse">
  <li><a href="#block-meshers" id="toc-block-meshers" class="nav-link" data-scroll-target="#block-meshers">Block meshers</a></li>
  <li><a href="#mesh-output" id="toc-mesh-output" class="nav-link" data-scroll-target="#mesh-output">Mesh output</a></li>
  </ul></li>
  <li><a href="#assembly" id="toc-assembly" class="nav-link" data-scroll-target="#assembly">Assembly</a>
  <ul class="collapse">
  <li><a href="#filtered-loops" id="toc-filtered-loops" class="nav-link" data-scroll-target="#filtered-loops">Filtered loops</a></li>
  <li><a href="#vector-assembly" id="toc-vector-assembly" class="nav-link" data-scroll-target="#vector-assembly">Vector assembly</a></li>
  <li><a href="#dense-matrix-assembly" id="toc-dense-matrix-assembly" class="nav-link" data-scroll-target="#dense-matrix-assembly">Dense matrix assembly</a></li>
  <li><a href="#coordinate-form-assembly" id="toc-coordinate-form-assembly" class="nav-link" data-scroll-target="#coordinate-form-assembly">Coordinate form assembly</a></li>
  <li><a href="#compressed-sparse-column-reassembly" id="toc-compressed-sparse-column-reassembly" class="nav-link" data-scroll-target="#compressed-sparse-column-reassembly">Compressed sparse column reassembly</a></li>
  </ul></li>
  <li><a href="#finite-element-mesh" id="toc-finite-element-mesh" class="nav-link" data-scroll-target="#finite-element-mesh">Finite element mesh</a>
  <ul class="collapse">
  <li><a href="#index-setup" id="toc-index-setup" class="nav-link" data-scroll-target="#index-setup">Index setup</a></li>
  <li><a href="#solution-updates" id="toc-solution-updates" class="nav-link" data-scroll-target="#solution-updates">Solution updates</a></li>
  <li><a href="#loads-and-bcs" id="toc-loads-and-bcs" class="nav-link" data-scroll-target="#loads-and-bcs">Loads and BCs</a></li>
  <li><a href="#assembly-1" id="toc-assembly-1" class="nav-link" data-scroll-target="#assembly-1">Assembly</a></li>
  <li><a href="#debugging-printer" id="toc-debugging-printer" class="nav-link" data-scroll-target="#debugging-printer">Debugging printer</a></li>
  </ul></li>
  <li><a href="#elements" id="toc-elements" class="nav-link" data-scroll-target="#elements">Elements</a>
  <ul class="collapse">
  <li><a href="#poisson-element" id="toc-poisson-element" class="nav-link" data-scroll-target="#poisson-element">Poisson element</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simple 1D FEM in Julia</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David Bindel </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This document is automatically extracted from the sources found at <a href="https://github.com/bindel-group/simple_jfem" class="uri">https://github.com/bindel-group/simple_jfem</a>. The code is written as a pedagogical example. It largely mirrors the structure of an analogous C code (<a href="https://github.com/bindel-group/simple_cfem" class="uri">https://github.com/bindel-group/simple_cfem</a>).</p>
</section>
<section id="shape-functions" class="level1">
<h1>Shape functions</h1>
<p>A <em>shape function</em> on a reference domain is a basis function used for interpolation on that domain. We will generally use Lagrange shape functions (also called nodal shape functions), which are one at one nodal point in a reference domain and zero at the others. We want to be able to compute both the values of all shape functions at a point in the domain and also their derivatives (stored as a matrix with <span class="math inline">\(d\)</span> rows for a <span class="math inline">\(d\)</span>-dimensional reference domain).</p>
<section id="d-building-blocks" class="level2">
<h2 class="anchored" data-anchor-id="d-building-blocks">1D building blocks</h2>
<p>A useful building block is the Lagrange polynomials through 2, 3, or 4 equispaced points, which span the linear (P1), quadratic (P2), and cubic (P3) polynomial spaces on <span class="math inline">\([-1, 1]\)</span>, respectively.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">shapes1dP1</span>(x) <span class="op">=</span> (<span class="fl">0.5</span><span class="fu">*</span>(<span class="fl">1</span><span class="op">-</span>x), <span class="fl">0.5</span><span class="fu">*</span>(<span class="fl">1</span><span class="op">+</span>x))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dshapes1dP1</span>(x) <span class="op">=</span>(<span class="op">-</span><span class="fl">0.5</span>,      <span class="fl">0.5</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">shapes1dP2</span>(x) <span class="op">=</span> (<span class="op">-</span><span class="fl">0.5</span><span class="fu">*</span>(<span class="fl">1</span><span class="op">-</span>x)<span class="op">*</span>x, (<span class="fl">1</span><span class="op">-</span>x)<span class="fu">*</span>(<span class="fl">1</span><span class="op">+</span>x), <span class="fl">0.5</span><span class="fu">*x*</span>(<span class="fl">1</span><span class="op">+</span>x))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">dshapes1dP2</span>(x) <span class="op">=</span>(<span class="op">-</span><span class="fl">0.5</span><span class="fu">*</span>(<span class="fl">1</span><span class="op">-</span><span class="fl">2</span><span class="op">*</span>x), <span class="op">-</span><span class="fl">2</span><span class="op">*</span>x,        <span class="fl">0.5</span><span class="fu">*</span>(<span class="fl">1</span><span class="op">+</span><span class="fl">2</span><span class="op">*</span>x))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">shapes1dP3</span>(x)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    (<span class="op">-</span><span class="fl">1.0</span><span class="op">/</span><span class="fl">16</span>) <span class="op">*</span> (<span class="fl">1</span><span class="op">-</span>x)<span class="fu">*</span>(<span class="fl">1</span><span class="op">-</span><span class="fl">3</span><span class="op">*</span>x)<span class="fu">*</span>(<span class="fl">1</span><span class="op">+</span><span class="fl">3</span><span class="op">*</span>x),</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    ( <span class="fl">9.0</span><span class="op">/</span><span class="fl">16</span>) <span class="op">*</span> (<span class="fl">1</span><span class="op">-</span>x)<span class="fu">*</span>(<span class="fl">1</span><span class="op">-</span><span class="fl">3</span><span class="op">*</span>x)<span class="fu">*</span>(<span class="fl">1</span><span class="op">+</span>x),</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    ( <span class="fl">9.0</span><span class="op">/</span><span class="fl">16</span>) <span class="op">*</span> (<span class="fl">1</span><span class="op">-</span>x)<span class="fu">*</span>(<span class="fl">1</span><span class="op">+</span><span class="fl">3</span><span class="op">*</span>x)<span class="fu">*</span>(<span class="fl">1</span><span class="op">+</span>x),</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    (<span class="op">-</span><span class="fl">1.0</span><span class="op">/</span><span class="fl">16</span>) <span class="op">*</span> (<span class="fl">1</span><span class="op">-</span><span class="fl">3</span><span class="op">*</span>x)<span class="fu">*</span>(<span class="fl">1</span><span class="op">+</span><span class="fl">3</span><span class="op">*</span>x)<span class="fu">*</span>(<span class="fl">1</span><span class="op">+</span>x)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">dshapes1dP3</span>(x)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="fl">1.0</span><span class="op">/</span><span class="fl">16</span> <span class="op">*</span> ( <span class="fl">1</span><span class="fu">+x*</span>( <span class="fl">18</span><span class="op">+</span>x<span class="op">*-</span><span class="fl">27</span>)),</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="fl">9.0</span><span class="op">/</span><span class="fl">16</span> <span class="op">*</span> (<span class="fu">-3+x*</span>(<span class="op">-</span><span class="fl">2</span><span class="op">+</span>x<span class="op">*</span> <span class="fl">9</span>)),</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="fl">9.0</span><span class="op">/</span><span class="fl">16</span> <span class="op">*</span> ( <span class="fl">3</span><span class="fu">+x*</span>(<span class="op">-</span><span class="fl">2</span><span class="op">+</span>x<span class="op">*-</span><span class="fl">9</span>)),</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="fl">1.0</span><span class="op">/</span><span class="fl">16</span> <span class="op">*</span> (<span class="fu">-1+x*</span>( <span class="fl">18</span><span class="op">+</span>x<span class="op">*</span> <span class="fl">27</span>))</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="shape-class-macro" class="level2">
<h2 class="anchored" data-anchor-id="shape-class-macro">Shape class macro</h2>
<p>We make a general structure type for accessing shape functions. For a given set of shapes, we keep some storage for the shape functions (<code>N</code>) and their derivatives (<code>dN</code>). Because we are defining the same types of methods for each instance, we use Julia’s macro facility to help write the routines for us.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">abstract type</span> ShapeFuns <span class="kw">end</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">macro</span> <span class="fu">make_shape</span>(classname, nfun, dim, body)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">quote</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> <span class="op">$</span>(<span class="fu">esc</span>(classname)) <span class="op">&lt;:</span><span class="dt"> ShapeFuns</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            N  <span class="op">::</span><span class="dt"> Vector{Float64}  </span><span class="co"># Shape functions (nshapes)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            dN <span class="op">::</span><span class="dt"> Matrix{Float64}  </span><span class="co"># Derivatives (nshapes-by-dshapes)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Default constructor</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span>(<span class="fu">esc</span>(classname))() <span class="op">=</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span>(<span class="fu">esc</span>(classname))(<span class="fu">zeros</span>(<span class="op">$</span>nfun), <span class="fu">zeros</span>(<span class="op">$</span>dim, <span class="op">$</span>nfun))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get the number of shapes and dimension of the space</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span>(<span class="fu">esc</span>(<span class="op">:</span>nshapes))( <span class="op">::</span><span class="dt"> $(esc</span>(classname))) <span class="op">=</span> <span class="op">$</span>nfun</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span>(<span class="fu">esc</span>(<span class="op">:</span>dshapes))( <span class="op">::</span><span class="dt"> $(esc</span>(classname))) <span class="op">=</span> <span class="op">$</span>dim</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Routine for actual computation (looks like a call to the object)</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">function</span> (s <span class="op">::</span><span class="dt"> $(esc</span>(classname)))(xx)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span>body</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            s</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="d-shape-functions" class="level2">
<h2 class="anchored" data-anchor-id="d-shape-functions">1D shape functions</h2>
<p>The 1D shape function classes just call the Lagrange polynomial support routines defined earlier. For each, shape, we also define a <code>refnodes</code> array with the list of reference-domain locations for the nodes.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@make_shape</span> Shapes1dP1 <span class="fl">2</span> <span class="fl">1</span> <span class="cf">begin</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> xx[<span class="fl">1</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    s.N[<span class="op">:</span>]  <span class="op">.=</span> <span class="fu">shapes1dP1</span>(x)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    s.dN[<span class="op">:</span>] <span class="op">.=</span> <span class="fu">dshapes1dP1</span>(x)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="fu">refnodes</span>(<span class="op">::</span><span class="dt"> Shapes1dP1</span>) <span class="op">=</span> [<span class="op">-</span><span class="fl">1.0</span> <span class="fl">1.0</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="pp">@make_shape</span> Shapes1dP2 <span class="fl">3</span> <span class="fl">1</span> <span class="cf">begin</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> xx[<span class="fl">1</span>]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    s.N[<span class="op">:</span>]  <span class="op">.=</span> <span class="fu">shapes1dP2</span>(x)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    s.dN[<span class="op">:</span>] <span class="op">.=</span> <span class="fu">dshapes1dP2</span>(x)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="fu">refnodes</span>(<span class="op">::</span><span class="dt"> Shapes1dP2</span>) <span class="op">=</span> [<span class="op">-</span><span class="fl">1.0</span> <span class="fl">0.0</span> <span class="fl">1.0</span>]</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="pp">@make_shape</span> Shapes1dP3 <span class="fl">4</span> <span class="fl">1</span> <span class="cf">begin</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> xx[<span class="fl">1</span>]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    s.N[<span class="op">:</span>]  <span class="op">.=</span> <span class="fu">shapes1dP3</span>(x)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    s.dN[<span class="op">:</span>] <span class="op">.=</span> <span class="fu">dshapes1dP3</span>(x)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="fu">refnodes</span>(<span class="op">::</span><span class="dt"> Shapes1dP3</span>) <span class="op">=</span> [<span class="op">-</span><span class="fl">1.0</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">/</span><span class="fl">3</span> <span class="fl">1.0</span><span class="op">/</span><span class="fl">3</span> <span class="fl">1.0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="d-shape-functions-1" class="level2">
<h2 class="anchored" data-anchor-id="d-shape-functions-1">2D shape functions</h2>
<p>The P1 and P2 shapes are just tensor products of the 1D P1 and P2 shapes. The serendipity element S2 is like the P2, but doesn’t keep the “bubble mode” shape function associated with the center node.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@make_shape</span> Shapes2dP1 <span class="fl">4</span> <span class="fl">2</span> <span class="cf">begin</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    Nx1,  Nx2  <span class="op">=</span> <span class="fu">shapes1dP1</span>(xx[<span class="fl">1</span>])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    Ny1,  Ny2  <span class="op">=</span> <span class="fu">shapes1dP1</span>(xx[<span class="fl">2</span>])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    dNx1, dNx2 <span class="op">=</span> <span class="fu">dshapes1dP1</span>(xx[<span class="fl">1</span>])</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    dNy1, dNy2 <span class="op">=</span> <span class="fu">dshapes1dP1</span>(xx[<span class="fl">2</span>])</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    s.N[<span class="op">:</span>]  <span class="op">.=</span> ( Nx1<span class="op">*</span> Ny1,  Nx2<span class="op">*</span> Ny1,  Nx2<span class="op">*</span> Ny2,  Nx1<span class="op">*</span> Ny2)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    s.dN[<span class="op">:</span>] <span class="op">.=</span> (dNx1<span class="op">*</span> Ny1, Nx1<span class="op">*</span>dNy1,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                dNx2<span class="op">*</span> Ny1, Nx2<span class="op">*</span>dNy1,</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                dNx2<span class="op">*</span> Ny2, Nx2<span class="op">*</span>dNy2,</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                dNx1<span class="op">*</span> Ny2, Nx1<span class="op">*</span>dNy2)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="fu">refnodes</span>(<span class="op">::</span><span class="dt"> Shapes2dP1</span>) <span class="op">=</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span>  <span class="op">-</span><span class="fl">1.0</span> ;</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>     <span class="op">-</span><span class="fl">1.0</span>  <span class="op">-</span><span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span> ]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="pp">@make_shape</span> Shapes2dP2 <span class="fl">9</span> <span class="fl">2</span> <span class="cf">begin</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    Nx1,  Nx2,  Nx3  <span class="op">=</span> <span class="fu">shapes1dP2</span>(xx[<span class="fl">1</span>])</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    Ny1,  Ny2,  Ny3  <span class="op">=</span> <span class="fu">shapes1dP2</span>(xx[<span class="fl">2</span>])</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    dNx1, dNx2, dNx3 <span class="op">=</span> <span class="fu">dshapes1dP2</span>(xx[<span class="fl">1</span>])</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    dNy1, dNy2, dNy3 <span class="op">=</span> <span class="fu">dshapes1dP2</span>(xx[<span class="fl">2</span>])</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    s.N[<span class="op">:</span>] <span class="op">.=</span>  ( Nx1<span class="op">*</span> Ny1,  Nx2<span class="op">*</span> Ny1,  Nx3<span class="op">*</span> Ny1,</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                 Nx3<span class="op">*</span> Ny2,  Nx3<span class="op">*</span> Ny3,  Nx2<span class="op">*</span> Ny3,</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>                 Nx1<span class="op">*</span> Ny3,  Nx1<span class="op">*</span> Ny2,  Nx2<span class="op">*</span> Ny2)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    s.dN[<span class="op">:</span>] <span class="op">.=</span> (dNx1<span class="op">*</span> Ny1, Nx1<span class="op">*</span>dNy1,</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>                dNx2<span class="op">*</span> Ny1, Nx2<span class="op">*</span>dNy1,</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                dNx3<span class="op">*</span> Ny1, Nx3<span class="op">*</span>dNy1,</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                dNx3<span class="op">*</span> Ny2, Nx3<span class="op">*</span>dNy2,</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                dNx3<span class="op">*</span> Ny3, Nx3<span class="op">*</span>dNy3,</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                dNx2<span class="op">*</span> Ny3, Nx2<span class="op">*</span>dNy3,</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>                dNx1<span class="op">*</span> Ny3, Nx1<span class="op">*</span>dNy3,</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>                dNx1<span class="op">*</span> Ny2, Nx1<span class="op">*</span>dNy2,</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>                dNx2<span class="op">*</span> Ny2, Nx2<span class="op">*</span>dNy2)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="fu">refnodes</span>(<span class="op">::</span><span class="dt"> Shapes2dP2</span>) <span class="op">=</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">1.0</span>   <span class="fl">0.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">0.0</span>  <span class="op">-</span><span class="fl">1.0</span>  <span class="op">-</span><span class="fl">1.0</span>   <span class="fl">0.0</span> ;</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>     <span class="op">-</span><span class="fl">1.0</span>  <span class="op">-</span><span class="fl">1.0</span>  <span class="op">-</span><span class="fl">1.0</span>   <span class="fl">0.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">0.0</span>   <span class="fl">0.0</span> ]</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span class="pp">@make_shape</span> Shapes2dS2 <span class="fl">8</span> <span class="fl">2</span> <span class="cf">begin</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> xx</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    Nx1,  Nx2,  Nx3  <span class="op">=</span> <span class="fu">shapes1dP2</span>(x)</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    Ny1,  Ny2,  Ny3  <span class="op">=</span> <span class="fu">shapes1dP2</span>(y)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    dNx1, dNx2, dNx3 <span class="op">=</span> <span class="fu">dshapes1dP2</span>(x)</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    dNy1, dNy2, dNy3 <span class="op">=</span> <span class="fu">dshapes1dP2</span>(y)</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    s.N[<span class="op">:</span>] <span class="op">.=</span>  ( Nx1<span class="op">*</span> Ny1,  Nx2<span class="op">*</span> Ny1,  Nx3<span class="op">*</span> Ny1,</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>                 Nx3<span class="op">*</span> Ny2,  Nx3<span class="op">*</span> Ny3,  Nx2<span class="op">*</span> Ny3,</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>                 Nx1<span class="op">*</span> Ny3,  Nx1<span class="op">*</span> Ny2)</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    s.dN[<span class="op">:</span>] <span class="op">.=</span> (dNx1<span class="op">*</span> Ny1, Nx1<span class="op">*</span>dNy1,</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>                dNx2<span class="op">*</span> Ny1, Nx2<span class="op">*</span>dNy1,</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>                dNx3<span class="op">*</span> Ny1, Nx3<span class="op">*</span>dNy1,</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>                dNx3<span class="op">*</span> Ny2, Nx3<span class="op">*</span>dNy2,</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>                dNx3<span class="op">*</span> Ny3, Nx3<span class="op">*</span>dNy3,</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>                dNx2<span class="op">*</span> Ny3, Nx2<span class="op">*</span>dNy3,</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>                dNx1<span class="op">*</span> Ny3, Nx1<span class="op">*</span>dNy3,</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>                dNx1<span class="op">*</span> Ny2, Nx1<span class="op">*</span>dNy2)</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a><span class="fu">refnodes</span>(<span class="op">::</span><span class="dt"> Shapes2dS2</span>) <span class="op">=</span></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">1.0</span>   <span class="fl">0.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">0.0</span>  <span class="op">-</span><span class="fl">1.0</span>  <span class="op">-</span><span class="fl">1.0</span>   <span class="fl">0.0</span> ;</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>     <span class="op">-</span><span class="fl">1.0</span>  <span class="op">-</span><span class="fl">1.0</span>  <span class="op">-</span><span class="fl">1.0</span>   <span class="fl">0.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">1.0</span>   <span class="fl">0.0</span>   <span class="fl">0.0</span> ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="triangle-shapes" class="level2">
<h2 class="anchored" data-anchor-id="triangle-shapes">Triangle shapes</h2>
<p>For now, we only have linear shape functions on a triangle.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@make_shape</span> Shapes2dT1 <span class="fl">3</span> <span class="fl">2</span> <span class="cf">begin</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> xx</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    s.N[<span class="op">:</span>]  <span class="op">.=</span> (<span class="fl">1.0</span><span class="op">-</span>x<span class="op">-</span>y, x, y)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    s.dN[<span class="op">:</span>] <span class="op">.=</span> (<span class="op">-</span><span class="fl">1.0</span>, <span class="op">-</span><span class="fl">1.0</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                 <span class="fl">1.0</span>,  <span class="fl">0.0</span>,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>                 <span class="fl">0.0</span>,  <span class="fl">1.0</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="fu">refnodes</span>(<span class="op">::</span><span class="dt"> Shapes2dT1</span>) <span class="op">=</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    [ <span class="fl">0.0</span> <span class="fl">1.0</span> <span class="fl">0.0</span> ;</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>      <span class="fl">0.0</span> <span class="fl">0.0</span> <span class="fl">1.0</span> ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="quadrature-rules" class="level1">
<h1>Quadrature rules</h1>
<p>Quadrature rules approximate integrals with formulas of the form <span class="math display">\[
  \int_{\Omega} f(x) \, d\Omega(x) \approx
  \sum_{j=1}^p f(\xi_{j}) w_j
\]</span> where <span class="math inline">\(\xi_j \in \Omega\)</span> and <span class="math inline">\(w_j \in \mathbb{R}\)</span> are known as the quadrature nodes (or points) and weights, respectively.</p>
<p>A good source of quadrature rules for various domains can be found in Stroud’s book on <em>Approximate calculation of multiple integrals</em> (Prentice Hall, 1971).</p>
<section id="gaussian-legendre-quadrature-rules" class="level2">
<h2 class="anchored" data-anchor-id="gaussian-legendre-quadrature-rules">Gaussian-Legendre quadrature rules</h2>
<p>Gauss-Legendre quadrature rules (sometimes just called Gauss quadrature rules when the context is clear) are <span class="math inline">\(p\)</span>-point rules on <span class="math inline">\([-1, 1]\)</span> that are characterized by the fact that they are exact when <span class="math inline">\(f\)</span> is a polynomial of degree at most <span class="math inline">\(2p-1\)</span>.</p>
<p>Gauss-Legendre nodes are zeros of Legendre polynomials, while the weights can be computed via an eigenvalue decomposition (using the Golub-Welsch algorithm). However, we do not need very high-order quadrature rules, and so only provide nodes and weights for rules up to <span class="math inline">\(p = 10\)</span> (probably more than we need), which are tabulated in many places. Because this is just a table lookup, we don’t bother to include the code in the automated documentation.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">gauss_point</span>(i, npts)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    gauss_pts <span class="op">=</span> (</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... the points</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    gauss_pts[( <span class="fu">npts*</span>(npts<span class="op">-</span><span class="fl">1</span>) )<span class="op">/</span><span class="fl">2</span> <span class="op">+</span> i]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">gauss_weight</span>(i, npts)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    gauss_wts <span class="op">=</span> (</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... and the weights</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    gauss_wts[( <span class="fu">npts*</span>(npts<span class="op">-</span><span class="fl">1</span>) )<span class="op">/</span><span class="fl">2</span> <span class="op">+</span> i]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="quadrature-iterator-interface" class="level2">
<h2 class="anchored" data-anchor-id="quadrature-iterator-interface">Quadrature iterator interface</h2>
<p>The <code>QuadratureRule</code> abstract type provides a base type for all quadrature rules. We assume that it provides methods</p>
<ul>
<li><code>quad_npoints(rule)</code>: Returns the number of points</li>
<li><code>quad_dim(rule)</code>: Returns the dimension of the reference domain</li>
<li><code>quad_point(rule, i)</code>: Returns the quadrature point <span class="math inline">\(\xi_i\)</span></li>
<li><code>quad_weight(rule, i)</code>: Returns the quadrature weight <span class="math inline">\(w_i\)</span></li>
</ul>
<p>One can also provide a <code>quad_pointwt</code> that returns the point and weight as a pair (by default, this just calls the individual <code>quad_point</code> and <code>quad_weight</code> methods.</p>
<p>For any quadrature rule, we overload the <code>Base.iterate</code> interface so that we can use it in <code>for</code> loops, writing expressions like</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> <span class="fu">sum</span>( <span class="fu">f</span>(xi) <span class="op">*</span> wt <span class="cf">for</span> (xi, wt) <span class="kw">in</span> rule )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>to approximate the integral via the rule.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">abstract type</span> QuadratureRule <span class="kw">end</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_pointwt</span>(q <span class="op">::</span><span class="dt"> QuadratureRule</span>, i) <span class="op">=</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">quad_point</span>(q, i), <span class="fu">quad_weight</span>(q, i))</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="fu">iterate</span>(q <span class="op">::</span><span class="dt"> QuadratureRule</span>, state<span class="op">=</span><span class="fl">1</span>) <span class="op">=</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    state <span class="op">&gt;</span> <span class="fu">quad_npoints</span>(q) ? <span class="cn">nothing</span> <span class="op">:</span> (<span class="fu">quad_pointwt</span>(q, state), state<span class="op">+</span><span class="fl">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="d-gauss-quadrature-interfaces" class="level2">
<h2 class="anchored" data-anchor-id="d-gauss-quadrature-interfaces">1D Gauss quadrature interfaces</h2>
<p>Our <code>GaussRule1d</code> rule just provides an alternate interface to the <code>gauss_point</code> and <code>gauss_weight</code> functions defined earlier</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> GaussRule1d <span class="op">&lt;:</span><span class="dt"> QuadratureRule</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    npts <span class="op">::</span><span class="dt"> Int</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_npoints</span>(q <span class="op">::</span><span class="dt"> GaussRule1d</span>) <span class="op">=</span> q.npts</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_dim</span>(q <span class="op">::</span><span class="dt"> GaussRule1d</span>) <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_point</span>(q <span class="op">::</span><span class="dt"> GaussRule1d</span>, i) <span class="op">=</span> <span class="fu">gauss_point</span>(i, q.npts)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_weight</span>(q <span class="op">::</span><span class="dt"> GaussRule1d</span>, i) <span class="op">=</span> <span class="fu">gauss_weight</span>(i, q.npts)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>GaussRule1dv</code> rule returns the quadrature points in a vector of length 1 (rather than returning them as scalars)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> GaussRule1dv <span class="op">&lt;:</span><span class="dt"> QuadratureRule</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    xi <span class="op">::</span><span class="dt"> Vector{Float64}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    npts <span class="op">::</span><span class="dt"> Int</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="fu">GaussRule1dv</span>(npts) <span class="op">=</span> <span class="fu">GaussRule1dv</span>(<span class="fu">zeros</span>(<span class="fl">1</span>), npts)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_npoints</span>(q <span class="op">::</span><span class="dt"> GaussRule1dv</span>) <span class="op">=</span> q.npts</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_dim</span>(q <span class="op">::</span><span class="dt"> GaussRule1dv</span>) <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">quad_point</span>(q <span class="op">::</span><span class="dt"> GaussRule1dv</span>, i)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    q.xi[<span class="fl">1</span>] <span class="op">=</span> <span class="fu">gauss_point</span>(i, q.npts)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    q.xi</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_weight</span>(q <span class="op">::</span><span class="dt"> GaussRule1dv</span>, i) <span class="op">=</span> <span class="fu">gauss_weight</span>(i, q.npts)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="product-gauss-rules" class="level2">
<h2 class="anchored" data-anchor-id="product-gauss-rules">Product Gauss rules</h2>
<p>A 2D tensor product Gauss rule for the domain <span class="math inline">\([-1,1]^2\)</span> involves a grid of <code>npts1</code>-by-<code>npts1</code> quadrature points with coordinates given by 1D Gauss quadrature rules.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> GaussRule2d <span class="op">&lt;:</span><span class="dt"> QuadratureRule</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    xi <span class="op">::</span><span class="dt"> Vector{Float64}</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    npts1 <span class="op">::</span><span class="dt"> Int</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="fu">GaussRule2d</span>(npts1) <span class="op">=</span> <span class="fu">GaussRule2d</span>(<span class="fu">zeros</span>(<span class="fl">2</span>), npts1)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_npoints</span>(q <span class="op">::</span><span class="dt"> GaussRule2d</span>) <span class="op">=</span> q.npts1 <span class="op">*</span> q.npts1</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_dim</span>(q <span class="op">::</span><span class="dt"> GaussRule2d</span>) <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">quad_point</span>(q <span class="op">::</span><span class="dt"> GaussRule2d</span>, i)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    ix, iy <span class="op">=</span> ((i<span class="op">-</span><span class="fl">1</span>)<span class="op">%</span>q.npts1)<span class="op">+</span><span class="fl">1</span>, <span class="fu">div</span>(i<span class="op">-</span><span class="fl">1</span>,q.npts1)<span class="op">+</span><span class="fl">1</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    q.xi[<span class="op">:</span>] <span class="op">.=</span> (<span class="fu">gauss_point</span>(ix, q.npts1), <span class="fu">gauss_point</span>(iy, q.npts1))</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    q.xi</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">quad_weight</span>(q <span class="op">::</span><span class="dt"> GaussRule2d</span>, i)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    ix, iy <span class="op">=</span> ((i<span class="op">-</span><span class="fl">1</span>)<span class="op">%</span>q.npts1)<span class="op">+</span><span class="fl">1</span>, <span class="fu">div</span>(i<span class="op">-</span><span class="fl">1</span>,q.npts1)<span class="op">+</span><span class="fl">1</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">gauss_weight</span>(ix, q.npts1) <span class="op">*</span> <span class="fu">gauss_weight</span>(iy, q.npts1)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">quad_pointwt</span>(q <span class="op">::</span><span class="dt"> GaussRule2d</span>, i)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    ix, iy <span class="op">=</span> ((i<span class="op">-</span><span class="fl">1</span>)<span class="op">%</span>q.npts1)<span class="op">+</span><span class="fl">1</span>, <span class="fu">div</span>(i<span class="op">-</span><span class="fl">1</span>,q.npts1)<span class="op">+</span><span class="fl">1</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    q.xi[<span class="op">:</span>] <span class="op">.=</span> (<span class="fu">gauss_point</span>(ix, q.npts1), <span class="fu">gauss_point</span>(iy, q.npts1))</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    wt <span class="op">=</span> <span class="fu">gauss_weight</span>(ix, q.npts1) <span class="op">*</span> <span class="fu">gauss_weight</span>(iy, q.npts1)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    (q.xi, wt)</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="triangle-mid-side-rule" class="level2">
<h2 class="anchored" data-anchor-id="triangle-mid-side-rule">Triangle mid-side rule</h2>
<p>For a triangle, a rule based on the three mid-side values is exact for every polynomial with total degree less than or equal to 2 (which is enough for our purposes). This is sometimes called the Hughes formula.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HughesRule2d <span class="op">&lt;:</span><span class="dt"> QuadratureRule</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    xi <span class="op">::</span><span class="dt"> Vector{Float64}</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="fu">HughesRule2d</span>() <span class="op">=</span> <span class="fu">HughesRule2d</span>(<span class="fu">zeros</span>(<span class="fl">2</span>))</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_npoints</span>(q <span class="op">::</span><span class="dt"> HughesRule2d</span>) <span class="op">=</span> <span class="fl">3</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_dim</span>(q <span class="op">::</span><span class="dt"> HughesRule2d</span>) <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_weight</span>(q <span class="op">::</span><span class="dt"> HughesRule2d</span>, i) <span class="op">=</span> <span class="fl">1.0</span><span class="op">/</span><span class="fl">6</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">quad_point</span>(q <span class="op">::</span><span class="dt"> HughesRule2d</span>, i)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    pts <span class="op">=</span> (<span class="fl">0.5</span>, <span class="fl">0.0</span>,</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>           <span class="fl">0.5</span>, <span class="fl">0.5</span>,</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>           <span class="fl">0.0</span>, <span class="fl">0.5</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    q.xi[<span class="op">:</span>] <span class="op">.=</span> pts[<span class="fl">2</span><span class="op">*</span>i<span class="op">-</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">*</span>i]</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="mapped-subdomains" class="level1">
<h1>Mapped subdomains</h1>
<p>Our shape functions and quadrature rules are defined on simple reference domains. To accommodate more complicated domains, we consider mappings <span class="math inline">\(\chi : \mathbb{R}^d \rightarrow \mathbb{R}^d\)</span> from a reference domain <span class="math inline">\(\Omega_0\)</span> into a spatial domain <span class="math inline">\(\Omega_e\)</span> (with <span class="math inline">\(\chi(\Omega_0) = \Omega_e\)</span>). We will typically write <span class="math inline">\(x = \chi(X)\)</span> for generic points in the spatial and reference domains.</p>
<section id="mapping-functions-and-derivatives" class="level2">
<h2 class="anchored" data-anchor-id="mapping-functions-and-derivatives">Mapping functions and derivatives</h2>
<p>With the mapping between domains in hand, We can identify functions <span class="math inline">\(f^0\)</span> in the reference domain with functions <span class="math inline">\(f^e\)</span> in the spatial domain: <span class="math display">\[
  f^e(x) = (f^0 \circ \chi^{-1})(x) = f^0(X)
\]</span> and the derivative mapping is given by <span class="math display">\[
  {f^e}'(x) = {f^0}'(X) J(X)^{-1}
\]</span> where <span class="math inline">\(J(X) = \partial \chi/\partial X\)</span> is the Jacobian of the reference-to-spatial mapping. In terms of gradients, we can write this as <span class="math display">\[
  \nabla_x f^e(x) = J(X)^{-T} \, \nabla_X f^0(X).
\]</span></p>
<p>Because we expect to be computing these types of transformations a lot, we would rather not constantly allocate and deallocate space for LU factorization objects. Therefore, we define helper functions that directly call the LAPACK interfaces for LU factorization of <span class="math inline">\(J\)</span> and subsequent solves with <span class="math inline">\(J^T\)</span> (for a generic gradient <span class="math inline">\(g\)</span> or for the shape function gradients stored in a <code>ShapeFuns</code> struct).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">r2s_factor!</span>(J, ipiv) <span class="op">=</span> LAPACK.<span class="fu">getrf!</span>(J, ipiv)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">r2s_gradients!</span>(J, ipiv, g <span class="op">::</span><span class="dt"> AbstractMatrix</span>) <span class="op">=</span> LAPACK.<span class="fu">getrs!</span>(<span class="ch">'T'</span>, J, ipiv, g)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">r2s_gradients!</span>(J, ipiv, s <span class="op">::</span><span class="dt"> ShapeFuns</span>) <span class="op">=</span> <span class="fu">r2s_gradients!</span>(J, ipiv, s.dN)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We also define a function to get the determinant out of the LU factorization of <span class="math inline">\(J\)</span>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">r2s_det</span>(J, ipiv)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    detJ <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(J,<span class="fl">2</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        detJ <span class="op">*=</span> J[k,k]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ipiv[k] <span class="op">!=</span> k</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>            detJ <span class="op">=</span> <span class="op">-</span>detJ</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    detJ</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="mapped-quadrature" class="level2">
<h2 class="anchored" data-anchor-id="mapped-quadrature">Mapped quadrature</h2>
<p>We can also express integrals over <span class="math inline">\(\Omega_e\)</span> in terms of integrals over <span class="math inline">\(\Omega_0\)</span> via the usual change of variables formula: <span class="math display">\[
  \int_{\Omega_e} f^e(x) \, dx =
  \int_{\Omega_0} f^0(X) |\det J(X)| \, dX.
\]</span> We will generally assume that <span class="math inline">\(\chi\)</span> is <em>positively-oriented</em>, that is, <span class="math inline">\(\det J\)</span> is positive over all points within <span class="math inline">\(\Omega_0\)</span>. Under this assumption, we can convert quadrature rules over the reference domain to mapped quadrature rules: <span class="math display">\[
  \int_{\Omega_e} f^e(x) \, dx \approx
  \sum_{j=1}^p f^e(\chi(\xi_j)) \det J(\xi_j) w_j.
\]</span></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MappedRule{T,M} <span class="op">&lt;:</span><span class="dt"> QuadratureRule </span><span class="kw">where</span> {T <span class="op">&lt;:</span><span class="dt"> QuadratureRule</span>}</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    base_rule <span class="op">::</span><span class="dt"> T                </span><span class="co"># Reference domain rule</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    chi!      <span class="op">::</span><span class="dt"> M                </span><span class="co"># Mapping</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    J         <span class="op">::</span><span class="dt"> Matrix{Float64}  </span><span class="co"># Space for Jacobian/LU</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    ipiv      <span class="op">::</span><span class="dt"> Vector{Int}      </span><span class="co"># Pivots for Jacobian LU</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="fu">MappedRule</span>(base_rule, chi!) <span class="op">=</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MappedRule</span>(base_rule, chi!,</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>               <span class="fu">zeros</span>(<span class="fu">quad_dim</span>(base_rule), <span class="fu">quad_dim</span>(base_rule)),</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>               <span class="fu">zeros</span>(<span class="dt">Int</span>, <span class="fu">quad_dim</span>(base_rule)))</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="fu">r2s_gradients!</span>(q <span class="op">::</span><span class="dt"> MappedRule</span>, g) <span class="op">=</span> <span class="fu">r2s_gradients!</span>(q.J, q.ipiv, g)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_npoints</span>(q <span class="op">::</span><span class="dt"> MappedRule</span>) <span class="op">=</span> <span class="fu">quad_npoints</span>(q.base_rule)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_dim</span>(q <span class="op">::</span><span class="dt"> MappedRule</span>) <span class="op">=</span> <span class="fu">quad_dim</span>(q.base_rule)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">quad_point</span>(q <span class="op">::</span><span class="dt"> MappedRule</span>, i)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="fu">quad_point</span>(q.base_rule, i)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    q.<span class="fu">chi!</span>(x, q.J)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">r2s_factor!</span>(q.J, q.ipiv)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By default, <code>quad_point</code> is called before <code>quad_weight</code>, and so we do not need to re-evaluate the mapping and its Jacobian</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">quad_weight</span>(q <span class="op">::</span><span class="dt"> MappedRule</span>, i; map <span class="op">=</span> <span class="cn">false</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> map <span class="fu">quad_point</span>(q, i) <span class="cf">end</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">quad_weight</span>(q.base_rule, i) <span class="op">*</span> <span class="fu">r2s_det</span>(q.J, q.ipiv)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="iso-parametric-mapping" class="level2">
<h2 class="anchored" data-anchor-id="iso-parametric-mapping">Iso-parametric mapping</h2>
<p>In some cases, the mapping function <span class="math inline">\(\chi\)</span> may be hand-crafted. Usually, though, we write <span class="math inline">\(\chi\)</span> as a combination of shape functions over the reference domain: <span class="math display">\[
  \chi(X) = \sum_{i=1}^m x_i N^e_i(X)
\]</span> where <span class="math inline">\(x_i\)</span> are given nodal locations and the functions <span class="math inline">\(N^e_i\)</span> are nodal basis functions (or Lagrange basis functions, or cardinal functions) for the interpolation set <span class="math inline">\(\xi_1, \ldots, \xi_m \in
\Omega_0\)</span>; that is <span class="math inline">\(N_i(\xi_j) = \delta_{ij}\)</span>. In this case, the Jacobian of the map is <span class="math display">\[
  \chi'(X) = \sum_{i=1}^m x_i {N^e_i}'(X).
\]</span></p>
<p>The reference domain nodes <span class="math inline">\(\xi_i\)</span> are typically placed at corners or on edges of the reference domain, and their images are at the corresponding locations in <span class="math inline">\(\Omega_e\)</span>. In order to ensure positive orientation of <span class="math inline">\(\chi\)</span>, the spatial nodes need to have the same type of placement as the reference domain nodes. For example, if the interpolation nodes appear in counterclockwise order in the reference domain, then they should also appear in counterclockwise order in the spatial domain.</p>
<p>When the same shape functions are used for defining the domain mapping and the interpolation of solution fields on the domain, we say we are using an <em>iso-parametric</em> mapping.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">isoparametric!</span>(shapes, xnodal, x, J)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">shapes</span>(x)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mul!</span>(x, xnodal, shapes.N,   <span class="fl">1.0</span>, <span class="fl">0.0</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mul!</span>(J, xnodal, shapes.dN<span class="op">'</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is useful to also define an isoparametric quadrature rule</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> IsoMappedRule{T <span class="op">&lt;:</span><span class="dt"> QuadratureRule</span>,</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>                     S <span class="op">&lt;:</span><span class="dt"> ShapeFuns</span>,</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                     M <span class="op">&lt;:</span><span class="dt"> AbstractMatrix</span>} <span class="op">&lt;:</span><span class="dt"> QuadratureRule</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    base_rule <span class="op">::</span><span class="dt"> T                </span><span class="co"># Reference domain rule</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    shapes    <span class="op">::</span><span class="dt"> S                </span><span class="co"># Shapes</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    xnodal    <span class="op">::</span><span class="dt"> M                </span><span class="co"># Nodal points</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    map_grads <span class="op">::</span><span class="dt"> Bool             </span><span class="co"># Flag whether to map gradients</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    J         <span class="op">::</span><span class="dt"> Matrix{Float64}  </span><span class="co"># Space for Jacobian/LU</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    ipiv      <span class="op">::</span><span class="dt"> Vector{Int}      </span><span class="co"># Pivots for Jacobian LU</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="fu">IsoMappedRule</span>(base_rule, shapes, xnodal, map_grads<span class="op">=</span><span class="cn">false</span>) <span class="op">=</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">IsoMappedRule</span>(base_rule, shapes, xnodal, map_grads,</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">zeros</span>(<span class="fu">quad_dim</span>(base_rule), <span class="fu">quad_dim</span>(base_rule)),</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">zeros</span>(<span class="dt">Int</span>, <span class="fu">quad_dim</span>(base_rule)))</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a><span class="fu">r2s_gradients!</span>(q <span class="op">::</span><span class="dt"> IsoMappedRule</span>, g) <span class="op">=</span> <span class="fu">r2s_gradients!</span>(q.J, q.ipiv, g)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_npoints</span>(q <span class="op">::</span><span class="dt"> IsoMappedRule</span>) <span class="op">=</span> <span class="fu">quad_npoints</span>(q.base_rule)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="fu">quad_dim</span>(q <span class="op">::</span><span class="dt"> IsoMappedRule</span>) <span class="op">=</span> <span class="fu">quad_dim</span>(q.base_rule)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">quad_point</span>(q <span class="op">::</span><span class="dt"> IsoMappedRule</span>, i)</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="fu">quad_point</span>(q.base_rule, i)</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">isoparametric!</span>(q.shapes, q.xnodal, x, q.J)</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">r2s_factor!</span>(q.J, q.ipiv)</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> q.map_grads <span class="fu">r2s_gradients!</span>(q, q.shapes) <span class="cf">end</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">quad_weight</span>(q <span class="op">::</span><span class="dt"> IsoMappedRule</span>, i; map <span class="op">=</span> <span class="cn">false</span>)</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> map <span class="fu">quad_point</span>(q, i) <span class="cf">end</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    <span class="fu">quad_weight</span>(q.base_rule, i) <span class="op">*</span> <span class="fu">r2s_det</span>(q.J, q.ipiv)</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="mesh-geometry" class="level1">
<h1>Mesh geometry</h1>
<p>A mesh consists of an array of nodes locations <span class="math inline">\(x_j \in
\mathbb{R}^d\)</span> and an element connectivity array with <code>elt[i,j]</code> giving the node number for the <span class="math inline">\(i\)</span>th node of the <span class="math inline">\(j\)</span>th element. Each element represents a subset of <span class="math inline">\(\Omega_e \subset \mathbb{R}^d\)</span> that is the image of a reference domain <span class="math inline">\(\Omega_0 \subset
\mathbb{R}^d\)</span> under a mapping <span class="math display">\[
  \chi(\xi) = \sum_{i=1}^{m} N^e_i(\xi) x_i
\]</span> where <span class="math inline">\(x_1, \ldots, x_m\)</span> are the <span class="math inline">\(m\)</span> element node positions corresponding to reference domain points <span class="math inline">\(\xi_1, \ldots, \xi_m\)</span>, and the shape functions <span class="math inline">\(N^e_i\)</span> are Lagrange basis functions on the reference domain.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Mesh{T}</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    shapes <span class="op">::</span><span class="dt"> T             </span><span class="co"># Shape function interface</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    X   <span class="op">::</span><span class="dt"> Matrix{Float64}  </span><span class="co"># Node positions</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    elt <span class="op">::</span><span class="dt"> Matrix{Int}      </span><span class="co"># Connectivity</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="fu">Mesh</span>(shapes, numnp <span class="op">::</span><span class="dt"> Integer</span>, numelt <span class="op">::</span><span class="dt"> Integer</span>) <span class="op">=</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Mesh</span>(shapes, <span class="fu">zeros</span>(<span class="fu">dshapes</span>(shapes), numnp),</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>         <span class="fu">zeros</span>(<span class="dt">Int</span>, <span class="fu">nshapes</span>(shapes), numelt))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="block-meshers" class="level2">
<h2 class="anchored" data-anchor-id="block-meshers">Block meshers</h2>
<p>One <em>can</em> allocate objects and then work out the node positions and element connectivity by hand (or with an external program). But in many cases, a simpler option is to programatically generate a mesh that covers a simple domain (e.g.&nbsp;a block) and then map the locations of the nodes. One can construct more complex meshes by combining this with a “tie” operation that merges the identity of nodes in the same location, but we will not bother with tied meshes for now.</p>
<p>The simplest mesher creates a 1D mesh on an interval <span class="math inline">\([a,b]\)</span>. We allow elements of order 1-3.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mesh_create1d</span>(numelt, shapes, a<span class="op">=</span><span class="fl">0.0</span>, b<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    nen   <span class="op">=</span> <span class="fu">nshapes</span>(shapes)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    numnp <span class="op">=</span> numelt <span class="op">*</span> (nen<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    mesh <span class="op">=</span> <span class="fu">Mesh</span>(shapes, numnp, numelt)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    mesh.X[<span class="op">:</span>] <span class="op">.=</span> <span class="fu">range</span>(a, b, length<span class="op">=</span>numnp)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>numelt</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        mesh.elt[<span class="op">:</span>,j] <span class="op">.=</span> (j<span class="op">-</span><span class="fl">1</span>)<span class="fu">*</span>(nen<span class="op">-</span><span class="fl">1</span>) <span class="op">.+</span> (<span class="fl">1</span><span class="op">:</span>nen)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    mesh</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Things are more complicated in 2D, and we have distinct mesh generation routines for the different types of shape functions described in the <code>shapes</code> module. Each of these generates a mesh of the region <span class="math inline">\([0,1]^2\)</span> with <code>nex</code>-by-<code>ney</code> elements.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mesh_block2d_P1</span>(nex, ney)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    nx, ny <span class="op">=</span> nex<span class="op">+</span><span class="fl">1</span>, ney<span class="op">+</span><span class="fl">1</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    mesh <span class="op">=</span> <span class="fu">Mesh</span>(<span class="fu">Shapes2dP1</span>(), nx<span class="op">*</span>ny, nex<span class="op">*</span>ney)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up nodes (row-by-row, SW to NE)</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iy <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>ny</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ix <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>nx</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> ix <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">*</span>nx</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>            mesh.X[<span class="op">:</span>,i] <span class="op">.=</span> ( (ix<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>(nx<span class="op">-</span><span class="fl">1</span>), (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>(ny<span class="op">-</span><span class="fl">1</span>) )</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up element connectivity</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iy <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>ney</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ix<span class="op">=</span><span class="fl">1</span><span class="op">:</span>nex</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> ix <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">*</span>nex</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>            i_sw <span class="op">=</span> ix <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="fu">*</span>(nex<span class="op">+</span><span class="fl">1</span>)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>            mesh.elt[<span class="op">:</span>,i] <span class="op">.=</span> (i_sw,</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">1</span>,</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">1</span> <span class="op">+</span> nex<span class="op">+</span><span class="fl">1</span>,</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> nex<span class="op">+</span><span class="fl">1</span>)</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    mesh</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mesh_block2d_P2</span>(nex, ney)</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    nx, ny <span class="op">=</span> <span class="fl">2</span><span class="op">*</span>nex<span class="op">+</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">*</span>ney<span class="op">+</span><span class="fl">1</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>    mesh <span class="op">=</span> <span class="fu">Mesh</span>(<span class="fu">Shapes2dP2</span>(), nx<span class="op">*</span>ny, nex<span class="op">*</span>ney)</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up nodes (row-by-row, SW to NE)    </span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iy <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>ny</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ix <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>nx</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> ix <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">*</span>nx</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>            mesh.X[<span class="op">:</span>,i] <span class="op">.=</span> ( (ix<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>(nx<span class="op">-</span><span class="fl">1</span>), (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>(ny<span class="op">-</span><span class="fl">1</span>) )</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up element connectivity</span></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iy <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>ney</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ix <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>nex</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> ix <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">*</span>nex</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>            i_sw <span class="op">=</span> <span class="fl">2</span><span class="fu">*</span>(ix<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> <span class="fl">2</span><span class="fu">*</span>(iy<span class="op">-</span><span class="fl">1</span>)<span class="op">*</span>nx <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>            mesh.elt[<span class="op">:</span>,i] <span class="op">.=</span> (i_sw,</span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">1</span>,</span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">2</span>,</span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">2</span> <span class="op">+</span> nx,</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">2</span> <span class="op">+</span> <span class="fl">2</span><span class="op">*</span>nx,</span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">2</span><span class="op">*</span>nx,</span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span>   <span class="op">+</span> <span class="fl">2</span><span class="op">*</span>nx,</span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span>   <span class="op">+</span> nx,</span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">1</span> <span class="op">+</span> nx)</span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>    mesh</span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mesh_block2d_S2</span>(nex, ney)</span>
<span id="cb21-61"><a href="#cb21-61" aria-hidden="true" tabindex="-1"></a>    nx0, nx1 <span class="op">=</span> <span class="fl">2</span><span class="op">*</span>nex<span class="op">+</span><span class="fl">1</span>, nex<span class="op">+</span><span class="fl">1</span>  <span class="co"># Even/odd row sizes</span></span>
<span id="cb21-62"><a href="#cb21-62" aria-hidden="true" tabindex="-1"></a>    numnp <span class="op">=</span> (ney<span class="op">+</span><span class="fl">1</span>)<span class="op">*</span>nx0 <span class="op">+</span> ney<span class="op">*</span>nx1</span>
<span id="cb21-63"><a href="#cb21-63" aria-hidden="true" tabindex="-1"></a>    mesh <span class="op">=</span> <span class="fu">Mesh</span>(<span class="fu">Shapes2dS2</span>(), numnp, nex<span class="op">*</span>ney)</span>
<span id="cb21-64"><a href="#cb21-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-65"><a href="#cb21-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up nodes (row-by-row, SW to NE)</span></span>
<span id="cb21-66"><a href="#cb21-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iy <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>ney</span>
<span id="cb21-67"><a href="#cb21-67" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="fu">*</span>(nx0<span class="op">+</span>nx1)</span>
<span id="cb21-68"><a href="#cb21-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-69"><a href="#cb21-69" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill bottom row</span></span>
<span id="cb21-70"><a href="#cb21-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ix <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>nx0</span>
<span id="cb21-71"><a href="#cb21-71" aria-hidden="true" tabindex="-1"></a>            mesh.X[<span class="op">:</span>,start<span class="op">+</span>ix] <span class="op">.=</span> ( (ix<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>(nx0<span class="op">-</span><span class="fl">1</span>), (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>ney )</span>
<span id="cb21-72"><a href="#cb21-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb21-73"><a href="#cb21-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-74"><a href="#cb21-74" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill middle row</span></span>
<span id="cb21-75"><a href="#cb21-75" aria-hidden="true" tabindex="-1"></a>        start <span class="op">+=</span> nx0</span>
<span id="cb21-76"><a href="#cb21-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ix <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>nx1</span>
<span id="cb21-77"><a href="#cb21-77" aria-hidden="true" tabindex="-1"></a>            mesh.X[<span class="op">:</span>,start<span class="op">+</span>ix] <span class="op">.=</span> ( (ix<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>(nx1<span class="op">-</span><span class="fl">1</span>), (iy<span class="op">-</span><span class="fl">0.5</span>)<span class="op">/</span>ney )</span>
<span id="cb21-78"><a href="#cb21-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb21-79"><a href="#cb21-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-80"><a href="#cb21-80" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-81"><a href="#cb21-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill top row</span></span>
<span id="cb21-82"><a href="#cb21-82" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> <span class="fu">ney*</span>(nx0<span class="op">+</span>nx1)</span>
<span id="cb21-83"><a href="#cb21-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ix <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>nx0</span>
<span id="cb21-84"><a href="#cb21-84" aria-hidden="true" tabindex="-1"></a>        mesh.X[<span class="op">:</span>,start<span class="op">+</span>ix] <span class="op">.=</span> ( (ix<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>(nx0<span class="op">-</span><span class="fl">1</span>), <span class="fl">1.0</span> )</span>
<span id="cb21-85"><a href="#cb21-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-86"><a href="#cb21-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-87"><a href="#cb21-87" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up element connectivity</span></span>
<span id="cb21-88"><a href="#cb21-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iy <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>ney</span>
<span id="cb21-89"><a href="#cb21-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ix <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>nex</span>
<span id="cb21-90"><a href="#cb21-90" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> ix <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">*</span>nex</span>
<span id="cb21-91"><a href="#cb21-91" aria-hidden="true" tabindex="-1"></a>            i_sw <span class="op">=</span> <span class="fl">2</span><span class="fu">*</span>(ix<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="fu">*</span>(nx0<span class="op">+</span>nx1) <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb21-92"><a href="#cb21-92" aria-hidden="true" tabindex="-1"></a>            i_ww <span class="op">=</span>   (ix<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="fu">*</span>(nx0<span class="op">+</span>nx1) <span class="op">+</span> nx0 <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb21-93"><a href="#cb21-93" aria-hidden="true" tabindex="-1"></a>            i_nw <span class="op">=</span> <span class="fl">2</span><span class="fu">*</span>(ix<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="fu">*</span>(nx0<span class="op">+</span>nx1) <span class="op">+</span> nx0 <span class="op">+</span> nx1 <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb21-94"><a href="#cb21-94" aria-hidden="true" tabindex="-1"></a>            mesh.elt[<span class="op">:</span>,i] <span class="op">.=</span> (i_sw,</span>
<span id="cb21-95"><a href="#cb21-95" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">1</span>,</span>
<span id="cb21-96"><a href="#cb21-96" aria-hidden="true" tabindex="-1"></a>                              i_sw <span class="op">+</span> <span class="fl">2</span>,</span>
<span id="cb21-97"><a href="#cb21-97" aria-hidden="true" tabindex="-1"></a>                              i_ww <span class="op">+</span> <span class="fl">1</span>,</span>
<span id="cb21-98"><a href="#cb21-98" aria-hidden="true" tabindex="-1"></a>                              i_nw <span class="op">+</span> <span class="fl">2</span>,</span>
<span id="cb21-99"><a href="#cb21-99" aria-hidden="true" tabindex="-1"></a>                              i_nw <span class="op">+</span> <span class="fl">1</span>,</span>
<span id="cb21-100"><a href="#cb21-100" aria-hidden="true" tabindex="-1"></a>                              i_nw,</span>
<span id="cb21-101"><a href="#cb21-101" aria-hidden="true" tabindex="-1"></a>                              i_ww)</span>
<span id="cb21-102"><a href="#cb21-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb21-103"><a href="#cb21-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-104"><a href="#cb21-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-105"><a href="#cb21-105" aria-hidden="true" tabindex="-1"></a>    mesh</span>
<span id="cb21-106"><a href="#cb21-106" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb21-107"><a href="#cb21-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-108"><a href="#cb21-108" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mesh_block2d_T1</span>(nex, ney)</span>
<span id="cb21-109"><a href="#cb21-109" aria-hidden="true" tabindex="-1"></a>    nx, ny <span class="op">=</span> nex<span class="op">+</span><span class="fl">1</span>, ney<span class="op">+</span><span class="fl">1</span></span>
<span id="cb21-110"><a href="#cb21-110" aria-hidden="true" tabindex="-1"></a>    mesh <span class="op">=</span> <span class="fu">Mesh</span>(<span class="fu">Shapes2dT1</span>(), nx<span class="op">*</span>ny, <span class="fl">2</span><span class="op">*</span>nex<span class="op">*</span>ney)</span>
<span id="cb21-111"><a href="#cb21-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-112"><a href="#cb21-112" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up nodes (row-by-row, SW to NE)</span></span>
<span id="cb21-113"><a href="#cb21-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iy <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>ney<span class="op">+</span><span class="fl">1</span></span>
<span id="cb21-114"><a href="#cb21-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ix <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>nex<span class="op">+</span><span class="fl">1</span></span>
<span id="cb21-115"><a href="#cb21-115" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> ix <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="fu">*</span>(nex<span class="op">+</span><span class="fl">1</span>)</span>
<span id="cb21-116"><a href="#cb21-116" aria-hidden="true" tabindex="-1"></a>            mesh.X[<span class="op">:</span>,i] <span class="op">.=</span> ( (ix<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>(nx<span class="op">-</span><span class="fl">1</span>), (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">/</span>(ny<span class="op">-</span><span class="fl">1</span>) )</span>
<span id="cb21-117"><a href="#cb21-117" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb21-118"><a href="#cb21-118" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-119"><a href="#cb21-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-120"><a href="#cb21-120" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up element connectivity</span></span>
<span id="cb21-121"><a href="#cb21-121" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iy <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>ney</span>
<span id="cb21-122"><a href="#cb21-122" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ix <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>nex</span>
<span id="cb21-123"><a href="#cb21-123" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> ix <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="op">*</span>nex;</span>
<span id="cb21-124"><a href="#cb21-124" aria-hidden="true" tabindex="-1"></a>            i_sw <span class="op">=</span> ix <span class="op">+</span> (iy<span class="op">-</span><span class="fl">1</span>)<span class="fu">*</span>(nex<span class="op">+</span><span class="fl">1</span>);</span>
<span id="cb21-125"><a href="#cb21-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-126"><a href="#cb21-126" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Two triangles makes a square</span></span>
<span id="cb21-127"><a href="#cb21-127" aria-hidden="true" tabindex="-1"></a>            mesh.elt[<span class="op">:</span>,<span class="fl">2</span><span class="op">*</span>i<span class="op">-</span><span class="fl">1</span>] <span class="op">.=</span> (i_sw, i_sw <span class="op">+</span> <span class="fl">1</span>, i_sw <span class="op">+</span> nex<span class="op">+</span><span class="fl">1</span>)</span>
<span id="cb21-128"><a href="#cb21-128" aria-hidden="true" tabindex="-1"></a>            mesh.elt[<span class="op">:</span>,<span class="fl">2</span><span class="op">*</span>i  ] <span class="op">.=</span> (i_sw <span class="op">+</span> nex<span class="op">+</span><span class="fl">1</span>, i_sw <span class="op">+</span> <span class="fl">1</span>, i_sw <span class="op">+</span> <span class="fl">1</span> <span class="op">+</span> nex<span class="op">+</span><span class="fl">1</span>)</span>
<span id="cb21-129"><a href="#cb21-129" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb21-130"><a href="#cb21-130" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-131"><a href="#cb21-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-132"><a href="#cb21-132" aria-hidden="true" tabindex="-1"></a>    mesh</span>
<span id="cb21-133"><a href="#cb21-133" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="mesh-output" class="level2">
<h2 class="anchored" data-anchor-id="mesh-output">Mesh output</h2>
<p>For debugging, it is helpful to be able to print out all or part of the mesh geometry. We mostly care about this for looking at small meshes.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mesh_print_nodes</span>(mesh)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@printf</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">Nodal Positions:</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@printf</span>(<span class="st">"   ID "</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">dshapes</span>(mesh.shapes)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"     X%d"</span>, j)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@printf</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(mesh.X,<span class="fl">2</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"%3d : "</span>, i)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">dshapes</span>(mesh.shapes)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>            <span class="pp">@printf</span>(<span class="st">" %6.2g"</span>, mesh.X[j,i])</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mesh_print_elt</span>(mesh)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@printf</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">Element connectivity:</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(mesh.elt,<span class="fl">2</span>)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"% 3d :"</span>, i)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(mesh.elt,<span class="fl">1</span>)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>            <span class="pp">@printf</span>(<span class="st">"  % 3d"</span>, mesh.elt[j,i])</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mesh_print</span>(mesh)</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mesh_print_nodes</span>(mesh)</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mesh_print_elt</span>(mesh)</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="assembly" class="level1">
<h1>Assembly</h1>
<p>Each element in a finite element discretization consists of</p>
<ul>
<li>A domain <span class="math inline">\(\Omega_e\)</span> for the <span class="math inline">\(e\)</span>th element, and</li>
<li>Local shape functions <span class="math inline">\(N^e_1, \ldots, N^e_m\)</span>, which are often Lagrange functions for interpolation at some set of nodes in <span class="math inline">\(\Omega_e\)</span>.</li>
</ul>
<p>Each local shape function on the domain <span class="math inline">\(\Omega_e\)</span> is the restriction of some global shape function on the whole domain <span class="math inline">\(\Omega\)</span>. That is, we have global shape functions <span class="math display">\[
  N_{j}(x) = \sum_{j = \iota(j',e)} N^e_{j'}(x),
\]</span> where <span class="math inline">\(\iota(j,e)\)</span> denotes the mapping from the local shape function index for element <span class="math inline">\(e\)</span> to the corresponding global shape function index. We only ever compute explicitly with the local functions <span class="math inline">\(N^e_j\)</span>; the global functions are implicit.</p>
<p><em>Assembly</em> is the process of reconstructing a quantity defined in terms of global shape functions from the contributions of the individual elements and their local shape functions. For example, to compute <span class="math display">\[
  F_i = \int_{\Omega} f(x) N_i(x) \, dx,
\]</span> we rewrite the integral as <span class="math display">\[
  F_i = \sum_{i = \iota(i',e)} \int_{\Omega_e} f(x) N^e_{i'}(x) \, dx.
\]</span> In code, this is separated into two pieces:</p>
<ul>
<li>Compute element contributions <span class="math inline">\(\int_{\Omega_e} f(x) N^e_{i'}(x) \, dx\)</span>. This is the responsibility of the element implementation.</li>
<li>Sum contributions into the global position <span class="math inline">\(i\)</span> corresponding to the element-local index <span class="math inline">\(i'\)</span>. This is managed by an assembly loop.</li>
</ul>
<p>The concept of an “assembly loop” is central to finite element methods, but it is not unique to this setting. For example, circuit simulators similarly construct system matrices (conductance, capacitance, etc) via the contributions of circuit elements (resistors, capacitors, inductors, and so forth).</p>
<p>We have two types of assembly loops that we care about: those that involve pairs of shape functions and result in matrices, and those that explicitly involve only a single shape function and result in vectors.</p>
<p>Our assemblers all implement two methods</p>
<ul>
<li><code>clear!(assembler)</code> – Clears things out</li>
<li><code>assemble_add!(assembler, econtrib, ids)</code> – add the element contribution <code>econtrib</code> at the locations indicated by <code>ids</code>. Any zero or negative indices are dropped.</li>
</ul>
<section id="filtered-loops" class="level2">
<h2 class="anchored" data-anchor-id="filtered-loops">Filtered loops</h2>
<p>We will sometimes also want to discard some element contributions that correspond to interactions with shape functions associated with known boundary values (for example). We also handle this filtering work as part of our assembly process. Because we do this a lot, we define an iterator over valid <code>(i, id)</code> pairs, where <code>i</code> is the index in the element numbering system and <code>id</code> is the corresponding reduced index in the global system (with Dirichlet BC indices skipped).</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> IdIterator{T <span class="op">&lt;:</span><span class="dt"> AbstractVector</span>} ids <span class="op">::</span><span class="dt"> T </span><span class="kw">end</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">iterate</span>(iter <span class="op">::</span><span class="dt"> IdIterator</span>, state<span class="op">=</span><span class="fl">1</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> state <span class="op">&lt;=</span> <span class="fu">length</span>(iter.ids) <span class="op">&amp;&amp;</span> iter.ids[state] <span class="op">&lt;=</span> <span class="fl">0</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        state <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    state <span class="op">&gt;</span> <span class="fu">length</span>(iter.ids) ? <span class="cn">nothing</span> <span class="op">:</span> ((state, iter.ids[state]), state<span class="op">+</span><span class="fl">1</span>)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="vector-assembly" class="level2">
<h2 class="anchored" data-anchor-id="vector-assembly">Vector assembly</h2>
<div class="sourceCode" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">clear!</span>(v <span class="op">::</span><span class="dt"> Vector</span>) <span class="op">=</span> (v[<span class="op">:</span>] <span class="op">.=</span> <span class="fl">0</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">assemble_add!</span>(v <span class="op">::</span><span class="dt"> Vector</span>, evec, ids)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i, id) <span class="kw">in</span> <span class="fu">IdIterator</span>(ids)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        v[id] <span class="op">+=</span> evec[i]</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="dense-matrix-assembly" class="level2">
<h2 class="anchored" data-anchor-id="dense-matrix-assembly">Dense matrix assembly</h2>
<div class="sourceCode" id="cb25"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">clear!</span>(A <span class="op">::</span><span class="dt"> Matrix</span>) <span class="op">=</span> (A[<span class="op">:</span>] <span class="op">.=</span> <span class="fl">0</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">assemble_add!</span>(A <span class="op">::</span><span class="dt"> Matrix</span>, emat, ids)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j, idj) <span class="kw">in</span> <span class="fu">IdIterator</span>(ids)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i, idi) <span class="kw">in</span> <span class="fu">IdIterator</span>(ids)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>            A[idi,idj] <span class="op">+=</span> emat[i,j]</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="coordinate-form-assembly" class="level2">
<h2 class="anchored" data-anchor-id="coordinate-form-assembly">Coordinate form assembly</h2>
<p>A coordinate form matrix (COO) is just a list of <code>(i,j,A[i,j])</code> tuples (which we will store in parallel arrays). We will follow the convention that entries with duplicate row/column indices are summed in the final matrix. We preallocate space for a certain number of entries, and keep a counter <code>nentries</code> for how much of that preallocation is used. We can reallocate if needed, but of course it is better not to do so.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">mutable struct</span> COOAssembler</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    I <span class="op">::</span><span class="dt"> Vector{Int}      </span><span class="co"># Row ids</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    J <span class="op">::</span><span class="dt"> Vector{Int}      </span><span class="co"># Column ids</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    V <span class="op">::</span><span class="dt"> Vector{Float64}  </span><span class="co"># Values</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    nentries <span class="op">::</span><span class="dt"> Int       </span><span class="co"># Number of entries saved</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    m <span class="op">::</span><span class="dt"> Int              </span><span class="co"># Rows in matrix</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    n <span class="op">::</span><span class="dt"> Int              </span><span class="co"># Columns in matrix</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="fu">COOAssembler</span>(nalloc <span class="op">::</span><span class="dt"> Int</span>, m, n<span class="op">=</span><span class="fl">0</span>) <span class="op">=</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COOAssembler</span>(<span class="fu">zeros</span>(<span class="dt">Int</span>, nalloc), <span class="fu">zeros</span>(<span class="dt">Int</span>, nalloc),</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">zeros</span>(nalloc), <span class="fl">0</span>, m, n <span class="op">&gt;</span> <span class="fl">0</span> ? n <span class="op">:</span> m)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Clearing the coordinate form assembler doesn’t require filling any space with zeros – we just reset the <code>nentries</code> counter.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">clear!</span>(assembler <span class="op">::</span><span class="dt"> COOAssembler</span>) <span class="op">=</span> (assembler.nentries <span class="op">=</span> <span class="fl">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>ensure_capacity!</code> function ensures that we have capacity for <code>ncontribs</code> more entries. If we do not have capacity in the pre-allocated space, we resize the arrays to either double the preallocated capacity or to accommodate the additional contributions, whichever is more.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ensure_capacity!</span>(assembler <span class="op">::</span><span class="dt"> COOAssembler</span>, ncontribs)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    nold <span class="op">=</span> <span class="fu">length</span>(assembler.V)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> assembler.nentries <span class="op">+</span> ncontribs <span class="op">&gt;</span> nold</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        nnew <span class="op">=</span> <span class="fu">max</span>(assembler.nentries <span class="op">+</span> ncontribs, <span class="fl">2</span><span class="op">*</span>nold)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">resize!</span>(assembler.I, nnew)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">resize!</span>(assembler.J, nnew)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">resize!</span>(assembler.V, nnew)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    assembler</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>add_entry!</code> function adds a single entry, assuming that capacity has already been ensured.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">add_entry!</span>(assembler <span class="op">::</span><span class="dt"> COOAssembler</span>, idi, idj, entry)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    assembler.nentries <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    assembler.I[assembler.nentries] <span class="op">=</span> idi</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    assembler.J[assembler.nentries] <span class="op">=</span> idj</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    assembler.V[assembler.nentries] <span class="op">=</span> entry</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, the <code>assembler_add!</code> function ensures that we have enough capacity, and then adds all the entries from the element matrix.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">assemble_add!</span>(assembler <span class="op">::</span><span class="dt"> COOAssembler</span>, emat, ids)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ensure_capacity!</span>(assembler, <span class="fu">length</span>(ids)<span class="op">^</span><span class="fl">2</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j, idj) <span class="kw">in</span> <span class="fu">IdIterator</span>(ids)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i, idi) <span class="kw">in</span> <span class="fu">IdIterator</span>(ids)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>            <span class="fu">add_entry!</span>(assembler, idi, idj, emat[i,j])</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The Julia <code>SparseArrays</code> package has a built-in function already to convert a coordinate form matrix in parallel arrays into a compressed sparse column representation.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">to_csc</span>(a <span class="op">::</span><span class="dt"> COOAssembler</span>) <span class="op">=</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sparse</span>(<span class="fu">view</span>(a.I, <span class="fl">1</span><span class="op">:</span>a.nentries),</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>           <span class="fu">view</span>(a.J, <span class="fl">1</span><span class="op">:</span>a.nentries),</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>           <span class="fu">view</span>(a.V, <span class="fl">1</span><span class="op">:</span>a.nentries), a.m, a.n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="compressed-sparse-column-reassembly" class="level2">
<h2 class="anchored" data-anchor-id="compressed-sparse-column-reassembly">Compressed sparse column reassembly</h2>
<p>The <code>CSCAssembler</code> keeps the data for assembling a compressed sparse column matrix. In addition to the storage for the matrix that we are assembling, we keep some auxiliary scratch storage for aggregating contributions to one column. This scratch storage is initialized to zeros, and should stay all zeros outside the <code>CSCAssembler</code> routines.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> CSCAssembler{Tv,Ti}</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    A <span class="op">::</span><span class="dt"> SparseMatrixCSC{Tv,Ti}  </span><span class="co"># CSC storage structure</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    Aj <span class="op">::</span><span class="dt"> Vector{Tv}             </span><span class="co"># Scratch vector</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="fu">CSCAssembler</span>(A <span class="op">::</span><span class="dt"> SparseMatrixCSC{Tv,Ti}</span>) <span class="kw">where</span> {Tv,Ti} <span class="op">=</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">CSCAssembler</span>(A, <span class="fu">zeros</span>(Tv, A.m))</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">clear!</span>(a <span class="op">::</span><span class="dt"> CSCAssembler</span>)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    a.A.nzval[<span class="op">:</span>] <span class="op">.=</span> <span class="fl">0.0</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    a.Aj[<span class="op">:</span>] <span class="op">.=</span> <span class="fl">0.0</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">assemble_add!</span>(a <span class="op">::</span><span class="dt"> CSCAssembler</span>, emat, ids)</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    nids <span class="op">=</span> <span class="fu">length</span>(ids)</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    A, Aj <span class="op">=</span> a.A, a.Aj</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j, idj) <span class="kw">in</span> <span class="fu">IdIterator</span>(ids)</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Populate dense column scratch</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i, idi) <span class="kw">in</span> <span class="fu">IdIterator</span>(ids)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>            Aj[idi] <span class="op">+=</span> emat[i,j]</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract from dense column</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>        k1, kn <span class="op">=</span> A.colptr[ids[j]], A.colptr[ids[j]<span class="op">+</span><span class="fl">1</span>]<span class="op">-</span><span class="fl">1</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="op">=</span> k1<span class="op">:</span>kn</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>            A.nzval[k] <span class="op">+=</span> Aj[A.rowval[k]]</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Clear dense columns scratch</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i, idi) <span class="kw">in</span> <span class="fu">IdIterator</span>(ids)</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>            Aj[idi] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="finite-element-mesh" class="level1">
<h1>Finite element mesh</h1>
<p>My finite element mesh data structure is informed by lots of old Fortran codes, and mostly is a big pile of arrays. Specifically, we have the nodal arrays:</p>
<ul>
<li><code>U</code>: Global array of solution values, <em>including</em> those that are determined by Dirichlet boundary conditions. Column <span class="math inline">\(j\)</span> represents the unknowns at node <span class="math inline">\(j\)</span> in the mesh.</li>
<li><code>F</code>: Global array of load values (right hand side evaluations of the forcing function in Poisson, for example; but Neumann boundary conditions can also contribute to <code>F</code>).</li>
<li><code>id</code>: Indices of solution values in a reduced solution vector. One column per node, with the same dimensions as <code>U</code> (and <code>F</code>), so that <code>ureduced[id[i,j]]</code> corresponds to <code>U[i,j]</code> when <code>id[i,j]</code> is nonnegative. The reduced solution vector contains only those variables that are not constrained a priori by boundary conditions; we mark the latter with negative entries in the <code>id</code> array.</li>
</ul>
<p>In addition, we keep a mesh, an element type, and a quadrature rule. Note that for the moment, we are assuming only one element type per problem; we could have a separate array of element types (one per element) if we wanted more flexibility.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">mutable struct</span> FEMProblem{T,S}</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mesh data</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    mesh <span class="op">::</span><span class="dt"> Mesh</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Element type (NB: can generalize with multiple types)</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    etype <span class="op">::</span><span class="dt"> T</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Quadrature rule</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    qrule <span class="op">::</span><span class="dt"> S</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Storage for fields</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    U  <span class="op">::</span><span class="dt"> Matrix{Float64}  </span><span class="co"># Global soln values (ndof-by-numnp)</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    F  <span class="op">::</span><span class="dt"> Matrix{Float64}  </span><span class="co"># Global force values (ndof-by-numnp)</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    id <span class="op">::</span><span class="dt"> Matrix{Int}      </span><span class="co"># Global to reduced ID map (ndof-by-nump)</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Dimensions</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    ndof <span class="op">::</span><span class="dt"> Int</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    nactive <span class="op">::</span><span class="dt"> Int</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">FEMProblem</span>(mesh, etype, qrule, ndof)</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>    numnp <span class="op">=</span> <span class="fu">size</span>(mesh.X,<span class="fl">2</span>)</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>    nactive <span class="op">=</span> numnp <span class="op">*</span> ndof</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> <span class="fu">zeros</span>(ndof, numnp)</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> <span class="fu">zeros</span>(ndof, numnp)</span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>    id <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Int</span>, ndof, numnp)</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>    <span class="fu">FEMProblem</span>(mesh, etype, qrule, U, F, id, ndof, nactive)</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="index-setup" class="level2">
<h2 class="anchored" data-anchor-id="index-setup">Index setup</h2>
<p>The <code>assign_ids!</code> function sets up the <code>id</code> array. On input, the <code>id</code> entries should be initialized so that boundary values are marked with negative numbers, and everything else is non-negative. On output, entries of <code>id</code> for variables not subject to essential boundary conditions will be assigned indices from 1 to <code>nactive</code> (and <code>nactive</code> will be updated appropriately).</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">assign_ids!</span>(fe <span class="op">::</span><span class="dt"> FEMProblem</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    nactive <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(fe.mesh.X,<span class="fl">2</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>fe.ndof</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> fe.id[i,j] <span class="op">&gt;=</span> <span class="fl">0</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>                nactive <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>                fe.id[i,j] <span class="op">=</span> nactive</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    fe.nactive <span class="op">=</span> nactive</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="solution-updates" class="level2">
<h2 class="anchored" data-anchor-id="solution-updates">Solution updates</h2>
<p>The <code>update_U!</code> function applies an update to the internal state. That we compute <code>U[i,j] -= du_red[id[i,j]]</code> for <code>id[i,j] &gt; 0</code>. If the update comes from <span class="math inline">\(K^{-1} R\)</span> where <span class="math inline">\(K\)</span> is the reduced tangent and <span class="math inline">\(R\)</span> the reduced residual, then applying the update will exactly solve the equation in the linear PDE case. However, we can also appy approximate updates (e.g.&nbsp;with an inexact solver for <span class="math inline">\(K\)</span>), and the same framework works for Newton iterations for nonlinear problems.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">update_U!</span>(fe <span class="op">::</span><span class="dt"> FEMProblem</span>, du_red)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(fe.mesh.X,<span class="fl">2</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>fe.ndof</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> fe.id[i,j] <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>                fe.U[i,j] <span class="op">-=</span> du_red[fe.id[i,j]]</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="loads-and-bcs" class="level2">
<h2 class="anchored" data-anchor-id="loads-and-bcs">Loads and BCs</h2>
<p>The <code>set_load!</code> function and <code>set_dirichlet!</code> function update the forcing array <code>F</code> and the boundary data entries and <code>id</code> array markers in <code>U</code> and <code>id</code>, respectively.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">set_load!</span>(fe <span class="op">::</span><span class="dt"> FEMProblem</span>, f <span class="op">::</span><span class="dt"> Function</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(fe.mesh.X,<span class="fl">2</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">f</span>(<span class="fu">view</span>(fe.mesh.X,<span class="op">:</span>,i), <span class="fu">view</span>(fe.F,<span class="op">:</span>,i))</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">set_dirichlet!</span>(fe <span class="op">::</span><span class="dt"> FEMProblem</span>, f <span class="op">::</span><span class="dt"> Function</span>)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(fe.mesh.X,<span class="fl">2</span>)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">f</span>(<span class="fu">view</span>(fe.mesh.X,<span class="op">:</span>,i), <span class="fu">view</span>(fe.id,<span class="op">:</span>,i), <span class="fu">view</span>(fe.U,<span class="op">:</span>,i))</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="assembly-1" class="level2">
<h2 class="anchored" data-anchor-id="assembly-1">Assembly</h2>
<p>The assembly loops iterate through the elements and produce a global residual and tangent stiffness based on the current solution state.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">assemble!</span>(fe <span class="op">::</span><span class="dt"> FEMProblem</span>, R <span class="op">::</span><span class="dt"> Vector</span>, K)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    nlocal <span class="op">=</span> <span class="fu">nshapes</span>(fe.mesh.shapes) <span class="op">*</span> fe.ndof</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    Re <span class="op">=</span> <span class="fu">zeros</span>(nlocal)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    Ke <span class="op">=</span> <span class="fu">zeros</span>(nlocal,nlocal)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    ids <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Int</span>, nlocal)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">clear!</span>(R)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">clear!</span>(K)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(fe.mesh.elt,<span class="fl">2</span>)</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>        ids[<span class="op">:</span>] <span class="op">.=</span> <span class="fu">reshape</span>(<span class="fu">view</span>(fe.id,<span class="op">:</span>,<span class="fu">view</span>(fe.mesh.elt,<span class="op">:</span>,i)),<span class="op">:</span>)</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        Re[<span class="op">:</span>] <span class="op">.=</span> <span class="fl">0.0</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>        Ke[<span class="op">:</span>] <span class="op">.=</span> <span class="fl">0.0</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">element_dR!</span>(fe, i, Re, Ke)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>        <span class="fu">assemble_add!</span>(R, Re, ids)</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">assemble_add!</span>(K, Ke, ids)</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>    R, K</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="debugging-printer" class="level2">
<h2 class="anchored" data-anchor-id="debugging-printer">Debugging printer</h2>
<div class="sourceCode" id="cb38"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">fem_print</span>(fe <span class="op">::</span><span class="dt"> FEMProblem</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@printf</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">Nodal information:</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@printf</span>(<span class="st">"       ID "</span>)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">dshapes</span>(fe.mesh.shapes)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"     X%d"</span>, j)</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>fe.ndof</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"     U%d"</span>, j)</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>fe.ndof</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"     F%d"</span>, j)</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@printf</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(fe.mesh.X,<span class="fl">2</span>)</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"%3d : "</span>, i)</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>ndof</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>            <span class="pp">@printf</span>(<span class="st">"% 3d "</span>, fe.id[i])</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">dshapes</span>(fe.mesh.shapes)</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>            <span class="pp">@printf</span>(<span class="st">" %6.2g"</span>, fe.mesh.X[j,i])</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>fe.ndof</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>            <span class="pp">@printf</span>(<span class="st">" % 6.2g"</span>, fe.U[j,i])</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>fe.ndof</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>            <span class="pp">@printf</span>(<span class="st">" % 6.2g"</span>, fe.F[j,i])</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@printf</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mesh_print_elt</span>(fe.mesh)</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="elements" class="level1">
<h1>Elements</h1>
<p>Abstractly, for steady-state problems, we are finding <span class="math inline">\(u(x) = \sum_j N_j(x) u_j\)</span> via an equation <span class="math display">\[
  R(u, N_i) = 0
\]</span> for all shape functions <span class="math inline">\(N_i\)</span> that are not associated with essential boundary conditions. The element routines compute the contribution of one element to the residual <span class="math inline">\(R\)</span> and to the tangent <span class="math inline">\(\partial R/\partial u_j\)</span>.</p>
<p>Different types of equations demand different types of elements. Even for a single type of element, we may depend on things like PDE coefficients or choices of material parameters (as well as implementation details like the quadrature rule used for computing integrals). An <code>element_t</code> object type keeps all this information together. The <code>element_t</code> data type should be thought of as representing a <em>type</em> of element, and not one specific element; usually many elements share fundamentally the same data, differing only in which nodes they involve. In the language of design patterns, this is an example of a “flyweight” pattern.</p>
<p>The main interface for an element is a method</p>
<pre><code>element_dR!(etype, fe, eltid, Re, Ke)</code></pre>
<p>where <code>etype</code> is data for the element type, <code>fe</code> is a finite element mesh data structure, <code>eltid</code> is the index of the element in the mesh, and <code>Re</code> and <code>Ke</code> are pointers to storage for the element residual and tangent matrix contributions. Either <code>Re</code> or <code>Ke</code> can be <code>nothing</code>, indicating that we don’t need that output.</p>
<p>Because we will usually use the element type associated with the finite element problem, we provide a convenience wrapper that fills in the <code>etype</code> argument to <code>element_dR!</code> with the problem <code>etype</code>.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">element_dR!</span>(fe <span class="op">::</span><span class="dt"> FEMProblem</span>, eltid, Re, Ke) <span class="op">=</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">element_dR!</span>(fe.etype, fe, eltid, Re, Ke)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="poisson-element" class="level2">
<h2 class="anchored" data-anchor-id="poisson-element">Poisson element</h2>
<p>Right now, we only have one element type, corresponding to a Poisson problem, written in weak form as <span class="math display">\[
R(u, N_i) =
\int_{\Omega} \left(
\nabla N_i(x) \cdot \nabla u(x) -
N_i(x) f(x) \right) \, d\Omega(x).
\]</span> There are no PDE coefficients or other special parameters to keep track of for this element type. This is also a simple enough problem that it’s easy to write dimension-independent code – no need for distinguishing 1D from 2D elements.</p>
<p>NB: We are not particularly careful in the current code about avoiding intermediate allocations.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> PoissonElt <span class="kw">end</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">element_dR!</span>(<span class="op">::</span><span class="dt"> PoissonElt</span>, fe <span class="op">::</span><span class="dt"> FEMProblem</span>, eltid, Re, Ke)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> fe.mesh.shapes</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    eltj <span class="op">=</span> <span class="fu">view</span>(fe.mesh.elt,<span class="op">:</span>,eltid)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> <span class="fu">view</span>(fe.mesh.X,<span class="op">:</span>,eltj)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> <span class="fu">view</span>(fe.U,<span class="fl">1</span>,eltj)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> <span class="fu">view</span>(fe.F,<span class="fl">1</span>,eltj)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    du <span class="op">=</span> <span class="fu">zeros</span>(<span class="fu">dshapes</span>(s))</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x,wt) <span class="kw">in</span> <span class="fu">IsoMappedRule</span>(fe.qrule, s, X, <span class="cn">true</span>)</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>        fx <span class="op">=</span>  F<span class="op">'</span> <span class="op">*</span> s.N</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">mul!</span>(du, s.dN, U)</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>        <span class="fu">mul!</span>(Re, s.dN<span class="op">'</span>, du,   wt, <span class="fl">1.0</span>)</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">mul!</span>(Re, s.N,   fx,  <span class="op">-</span>wt, <span class="fl">1.0</span>)</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">mul!</span>(Ke, s.dN<span class="op">'</span>, s.dN, wt, <span class="fl">1.0</span>)</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>